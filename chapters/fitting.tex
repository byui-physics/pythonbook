\chapter{Fitting Functions to Data}
\label{chap:Fitting}

As a scientist(or engineer), you will frequently gather data.  Usually
when you gather data, the goal is to use that data to uncover some
relationship between the two variables.  In other words, you'd like to
find a function that best mimicks that data that you've gathered.  In
this chapter you'll see how to do that.

\section{Fitting to Linear Functions}
When you think of fitting a function to a data set you most likely
think of least-squares fitting.  Mathematically, this can be stated
as minimzing the following quantity:
\begin{equation}
\sum_{i=1}^N (y_i - f(x_i))^2
\end{equation}
Here, $y_i$ represents the data point collected at $x_i$ and $f(x)$ represents
the fitting function evaluated at $x_i$.  By varying the parameters in
the function until the above sum is minimized, you are finding the
function that best mimicks the data.

\section{Fitting to an Arbitrary Function}
The \code{scipy.optimizes} library contains a wealth of useful function, one
of which is called \code{curve\_fit}.  Sounds promising, right?
Let's try it out.  Assume you've collected the following data

\begin{Verbatim}
x = [4.30949, 5.33127, 2.21479, 5.56794, 3.49002, 0.00272514, 1.3348, \
7.90191, 6.79002, 0.0857548]

y = [0.418161, -0.328667, -1.58646, -0.305927, 0.56044, 0.0272141, \
1.16629, -0.0092056, 0.142341, 0.817534]
\end{Verbatim}
and you decide it would be a prudent choice to attempt to fit this
data to the function
\begin{equation}
y(x)  = a \sin(b x) \exp(c x)
\end{equation}
Your task then is to find values for \texttt{a}, \texttt{b}, and
\texttt{c} that make the function the best approximation to the data.
To do that we must send our data into the function
\code{curve\_fit}. First, we need to import the library and define the
function being fitted to:
\begin{Verbatim}
import scipy.optimize as opt

def func(x,a,b,c)
    retun a * sin(b*x) * exp(c * x)

fit = opt.curve_fit(func,x,y)
\end{Verbatim}
Notice that I have defined the function that I am trying to fit the
data to and called it \code{func}.  When defining this function,
take note that the first argument must be the independent variable (x
in this case) and after that you are free to put as many adjustable
parameters as you need.  In this case we had three (a,b, and c).  The
\code{curve\_fit} function requires three arguments: The function that
is being fitted, the independent variable values, and the dependent
variables values (in that order).  
The \code{curve\_fit} function returns a list of two things.  The
first thing is a list of the parameter values.  The second thing is
the variance (uncertainty) in the parameter values.  You can access
these just as you would do with any other list.
There are several optional arguments that can be passed to
this function.  For example, you can specify a guess at the solution
and that guess will serve as a starting point.
\begin{Verbatim}
guess = [2.5,1.2,-3]  # Guess for a, b, and c.
fit = opt.curve_fit(func,x,y,p0=guess)
\end{Verbatim}
You can specify bounds on the search parameters:
\begin{Verbatim}
# Set bounds on a to (0,4)
# Set bounds on b to (0,3)
 # Set bounds on c to (-4,2)
paramBounds = [[0,0,-4],[4,3,2]] 
fit = opt.curve_fit(func,x,y,bounds=paramBounds)
\end{Verbatim}
and you can specify the uncertainty in the data points
\begin{Verbatim}
#Specify uncertainty on each data point
uncertainty = [0.01,0.02,0.1,0.2,0.05,0.2,0.5,0.01,0.02,0.01,0.1,0.05]  
fit = opt.curve_fit(func,x,y,sigma=uncertainty)
\end{Verbatim}

\section{Plotting the Fit}
The function \code{curve\_fit} will return several things.  The
first thing is the values of the fit parameters, which is the thing
you are most interested in.  Once you have those you can proceed to
plot the function just as we showed you in chapter \ref{chap:Plotting}.
Here I'll show you again (recall that the variable \code{fit}
contains the fit results)
\begin{Verbatim}
fitA = fit[0][0]  # Pull out value of a
fitB = fit[0][1]  # Pull out value of b
fitC = fit[0][2]  # Pull out value of c

xVals = arange(0,15,0.1)  # Define a grid of points on my domain

#Evaluate my fit function over the entire domain
#using my newly-found fit parameters
yVals = fitA * sin(fitB * xVals) * exp(fitC * xVals)
pyplot.scatter(x,y)  #Plot the data
pyplot.plot(xVals,yVals)  #Plot the fit function
pyplot.show()  #Show results.
\end{Verbatim}
